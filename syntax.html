<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Syntax Lab - PiPlexion Lab</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="favicon.png" type="image/png">
</head>
<body>

<!-- Navigation Menu -->
<nav>
  <a href="index.html">Home</a> |
  <a href="phonetics.html">Phonetics Lab</a> |
  <a href="morphology.html">Morphology Lab</a> |
  <a href="semantics.html">Semantics Lab</a> |
  <a href="pragmatics.html">Pragmatics Lab</a> |
  <a href="discourse.html">Discourse Lab</a> |
  <a href="about.html">About</a>
</nav>
<hr>

<!-- Syntax Lab -->
<section class="tool-box">
  <h2>Syntax Lab</h2>
  <p>
     Generate tree diagrams
  </p>

  <!-- External stylesheet (colors & theme controlled there) -->
  <link rel="stylesheet" href="style.css">

  <!-- Tree Generator -->
<section id="Tree Generator" class="tool-box">
<div class="input-group">
    <label for="bracketInput">Enter Bracketed Notation:</label>
    <textarea id="bracketInput" placeholder="[S [NP This] [VP [V is] [^NP an apple]]]">[S [NP This] [VP [V is] [^NP an apple]]]</textarea>
    <button onclick="generateTree()" class="btn-generate">Generate Tree</button>
</div>

<div class="output-group">
    <p class="instruction-text">Click the tree image below to download it.</p>
    <div id="tree-display-box" class="tree-canvas-container">
        <canvas id="treeCanvas"></canvas>
    </div>
</div>

<script>

</div>
​<script>
/**
​Syntactic Tree Generator Logic
​Logic handles nested brackets and the '^' symbol for triangles. */
​function generateTree() {
const input = document.getElementById('bracketInput').value;
const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d');
// Simple recursive parser
function parse(str) {
    str = str.trim();
    if (str[0] !== &#39;[&#39;) return { label: str, children: [] };
    
    let content = str.substring(1, str.length - 1).trim();
    let spaceIdx = content.indexOf(&#39; &#39;);
    if (spaceIdx === -1) return { label: content, children: [] };
    
    let label = content.substring(0, spaceIdx);
    let childrenStr = content.substring(spaceIdx).trim();
    let children = [];
    let bracketCount = 0;
    let start = 0;

    for (let i = 0; i &lt; childrenStr.length; i++) {
        if (childrenStr[i] === &#39;[&#39;) bracketCount++;
        else if (childrenStr[i] === &#39;]&#39;) bracketCount--;
        
        if (bracketCount === 0 &amp;&amp; childrenStr[i] === &#39; &#39; || i === childrenStr.length - 1) {
            let chunk = childrenStr.substring(start, i + 1).trim();
            if (chunk) children.push(parse(chunk));
            start = i + 1;
        }
    }
    return { label, children };
}

const treeData = parse(input);

// Basic Drawing Logic (simplified for brevity)
// In a real implementation, you&#39;d calculate widths/depths
// To match Miles Shang, we clear and draw:
ctx.clearRect(0, 0, canvas.width, canvas.height);
ctx.font = &quot;16px Arial&quot;;
ctx.textAlign = &quot;center&quot;;

// Set Canvas Size dynamically based on tree depth/width
canvas.width = 800; 
canvas.height = 500;

function drawNode(node, x, y, levelWidth) {
    let isTriangle = node.label.startsWith(&#39;^&#39;);
    let cleanLabel = isTriangle ? node.label.substring(1) : node.label;
    
    ctx.fillText(cleanLabel, x, y);
    
    if (node.children.length &gt; 0) {
        let childX = x - (levelWidth / 2);
        let step = levelWidth / (node.children.length);
        childX += step / 2;

        node.children.forEach(child =&gt; {
            ctx.beginPath();
            if (isTriangle) {
                // Draw Triangle
                ctx.moveTo(x, y + 5);
                ctx.lineTo(childX - 15, y + 35);
                ctx.lineTo(childX + 15, y + 35);
                ctx.closePath();
            } else {
                // Draw Line
                ctx.moveTo(x, y + 5);
                ctx.lineTo(childX, y + 30);
            }
            ctx.stroke();
            drawNode(child, childX, y + 50, levelWidth / 2);
            childX += step;
        });
    }
}

drawNode(treeData, canvas.width / 2, 40, 400);

// Download functionality
canvas.onclick = function() {
    const link = document.createElement(&#39;a&#39;);
    link.download = &#39;syntax-tree.png&#39;;
    link.href = canvas.toDataURL();
    link.click();
};

}
​// Initial Run
window.onload = generateTree;
</script>
​<style>
/* Integrating your existing site colors /
.tool-container {
padding: 20px;
border-radius: 8px;
background-color: var(--bg-secondary); / Uses your style.css colors */
box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}
​.tool-title {
color: var(--primary-color);
margin-bottom: 20px;
border-bottom: 2px solid var(--accent-color);
}
​#bracketInput {
width: 100%;
height: 100px;
padding: 10px;
border: 1px solid #ccc;
border-radius: 4px;
font-family: monospace;
}
​.tree-canvas-container {
margin-top: 20px;
border: 2px dashed var(--accent-color);
padding: 20px;
background: #fff;
overflow: auto;
cursor: pointer;
}
​.btn-generate {
margin-top: 10px;
padding: 10px 25px;
background-color: var(--primary-color);
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
}
​.btn-generate:hover {
filter: brightness(1.1);
}
</style>


  
</section>

<!-- Footer -->
<footer>
  <hr>
  <p>
    © 2026 <strong>PiPlexion</strong>.<br>
    This web app (including text, interface, and underlying code) is licensed under a
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">
      Creative Commons Attribution–NonCommercial–NoDerivatives 4.0 International License
    </a>.<br>
    Please cite PiPlexion when using this tool for academic or educational purposes.<br>
    Website: <a href="https://piplexion.github.io" target="_blank">https://piplexion.github.io</a>
  </p>
</footer>

</body>
</html>
